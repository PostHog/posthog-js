'use strict'
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self['webpackHotUpdate_N_E']('pages/_app', {
    /***/ './src/posthogReplayReduxLogger.ts':
        /*!*****************************************!*\
  !*** ./src/posthogReplayReduxLogger.ts ***!
  \*****************************************/
        /***/ (module, __webpack_exports__, __webpack_require__) => {
            eval(
                __webpack_require__.ts(
                    '__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   posthogReplayReduxLogger: () => (/* binding */ posthogReplayReduxLogger)\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_object_without_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @swc/helpers/_/_object_without_properties */ "../../../../node_modules/.pnpm/@swc+helpers@0.5.13/node_modules/@swc/helpers/esm/_object_without_properties.js");\n/* harmony import */ var _swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @swc/helpers/_/_to_consumable_array */ "../../../../node_modules/.pnpm/@swc+helpers@0.5.13/node_modules/@swc/helpers/esm/_to_consumable_array.js");\n/* harmony import */ var _swc_helpers_type_of__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @swc/helpers/_/_type_of */ "../../../../node_modules/.pnpm/@swc+helpers@0.5.13/node_modules/@swc/helpers/esm/_type_of.js");\n// Redux-compatible types without depending on Redux\n// Copied from https://github.com/reduxjs/redux/blob/6c8c3a10f6e5a35f0c4a61413d7a93a53e4f11d4/src/types/actions.ts#L32\n/**\n * An Action type which accepts any other properties.\n * This is mainly for the use of the `Reducer` type.\n * This is not part of `Action` itself to prevent types that extend `Action` from\n * having an index signature.\n */ \n\n\n/**\n * Default title function for Redux events\n */ function defaultTitleFunction(reduxEvent) {\n    var type = reduxEvent.type, executionTimeMs = reduxEvent.executionTimeMs;\n    var timeText = executionTimeMs !== undefined ? " (".concat(executionTimeMs.toFixed(2), "ms)") : \'\';\n    return "[PostHog Redux Logger] ".concat(type).concat(timeText);\n}\nfunction defaultLogger(title, reduxEvent) {\n    console.log(title, reduxEvent);\n}\n/**\n * Get only the changed keys from two states\n * Returns { prevState: changedKeysOnly, nextState: changedKeysOnly }\n */ function getChangedStateKeys(prevState, nextState) {\n    if (prevState === nextState) {\n        return {\n            prevState: {},\n            nextState: {}\n        };\n    }\n    if ((typeof prevState === "undefined" ? "undefined" : (0,_swc_helpers_type_of__WEBPACK_IMPORTED_MODULE_0__._)(prevState)) !== \'object\' || (typeof nextState === "undefined" ? "undefined" : (0,_swc_helpers_type_of__WEBPACK_IMPORTED_MODULE_0__._)(nextState)) !== \'object\' || prevState === null || nextState === null) {\n        return {\n            prevState: prevState,\n            nextState: nextState\n        };\n    }\n    if (Array.isArray(prevState) || Array.isArray(nextState)) {\n        return {\n            prevState: prevState,\n            nextState: nextState\n        };\n    }\n    var prevFiltered = {};\n    var nextFiltered = {};\n    var allKeys = new Set((0,_swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_1__._)(Object.keys(prevState)).concat((0,_swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_1__._)(Object.keys(nextState))));\n    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n    try {\n        for(var _iterator = allKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n            var key = _step.value;\n            var prevValue = prevState[key];\n            var nextValue = nextState[key];\n            if (!(key in prevState)) {\n                // Key was added\n                nextFiltered[key] = nextValue;\n            } else if (!(key in nextState)) {\n                // Key was removed\n                prevFiltered[key] = prevValue;\n            } else if (prevValue !== nextValue) {\n                // Key was changed\n                if ((typeof prevValue === "undefined" ? "undefined" : (0,_swc_helpers_type_of__WEBPACK_IMPORTED_MODULE_0__._)(prevValue)) === \'object\' && (typeof nextValue === "undefined" ? "undefined" : (0,_swc_helpers_type_of__WEBPACK_IMPORTED_MODULE_0__._)(nextValue)) === \'object\' && prevValue !== null && nextValue !== null && !Array.isArray(prevValue) && !Array.isArray(nextValue)) {\n                    // Recursively handle nested objects\n                    var nested = getChangedStateKeys(prevValue, nextValue);\n                    if (Object.keys(nested.prevState).length > 0 || Object.keys(nested.nextState).length > 0) {\n                        if (Object.keys(nested.prevState).length > 0) prevFiltered[key] = nested.prevState;\n                        if (Object.keys(nested.nextState).length > 0) nextFiltered[key] = nested.nextState;\n                    }\n                } else {\n                    // Primitive values or arrays - include both\n                    prevFiltered[key] = prevValue;\n                    nextFiltered[key] = nextValue;\n                }\n            }\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally{\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n            }\n        } finally{\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n    return {\n        prevState: prevFiltered,\n        nextState: nextFiltered\n    };\n}\n/**\n * Creates a Redux middleware that logs actions and state changes for PostHog session replay\n * This can be used as middleware in any Redux store to capture state changes\n */ function posthogReplayReduxLogger() {\n    var config = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    var _config_maskReduxAction = config.maskReduxAction, maskReduxAction = _config_maskReduxAction === void 0 ? function(action) {\n        return action;\n    } : _config_maskReduxAction, _config_maskReduxState = config.maskReduxState, maskReduxState = _config_maskReduxState === void 0 ? function(state) {\n        return state;\n    } : _config_maskReduxState, _config_titleFunction = config.titleFunction, titleFunction = _config_titleFunction === void 0 ? defaultTitleFunction : _config_titleFunction, _config_logger = config.logger, logger = _config_logger === void 0 ? defaultLogger : _config_logger, _config_diffState = config.diffState, diffState = _config_diffState === void 0 ? true : _config_diffState;\n    return function(store) {\n        return function(next) {\n            return function(action) {\n                // Get the state before the action\n                var prevState = store.getState();\n                // Track execution time\n                // eslint-disable-next-line compat/compat\n                var startTime = performance.now();\n                var result = next(action);\n                // eslint-disable-next-line compat/compat\n                var endTime = performance.now();\n                var executionTimeMs = endTime - startTime;\n                // Get the state after the action\n                var nextState = store.getState();\n                var maskedAction = maskReduxAction(action);\n                if (!maskedAction) {\n                    return result;\n                }\n                // Apply masking to states\n                var maskedPrevState = maskReduxState(prevState, maskedAction);\n                var maskedNextState = maskReduxState(nextState, maskedAction);\n                var filteredPrevState;\n                var filteredNextState;\n                if (diffState) {\n                    var _getChangedStateKeys = getChangedStateKeys(maskedPrevState, maskedNextState), diffedPrevState = _getChangedStateKeys.prevState, diffedNextState = _getChangedStateKeys.nextState;\n                    filteredPrevState = diffedPrevState;\n                    filteredNextState = diffedNextState;\n                } else {\n                    filteredPrevState = maskedPrevState;\n                    filteredNextState = maskedNextState;\n                }\n                var type = maskedAction.type, actionData = (0,_swc_helpers_object_without_properties__WEBPACK_IMPORTED_MODULE_2__._)(maskedAction, [\n                    "type"\n                ]);\n                var reduxEvent = {\n                    type: type,\n                    payload: actionData,\n                    timestamp: Date.now(),\n                    executionTimeMs: executionTimeMs,\n                    prevState: filteredPrevState,\n                    nextState: filteredNextState\n                };\n                logger(titleFunction(reduxEvent), reduxEvent);\n                return result;\n            };\n        };\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we\'re in a\n        // browser context before continuing.\n        if (typeof self !== \'undefined\' &&\n            // AMP / No-JS mode does not inject these helpers:\n            \'$RefreshHelpers$\' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we\'ll check if it\'s\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we\'ll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it\'s possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LGtCQUErQkYscUJBQS9CRTtvQkFJcENrQyxvQkFBb0JFO29CQUNwQkQsb0JBQW9CRTtnQkFDeEIsT0FBTztvQkFDSEgsb0JBQW9CRjtvQkFDcEJHLG9CQUFvQkY7Z0JBQ3hCO2dCQUVBLElBQU0sT0FBMEJGLGFBQXhCMUMsTUFBU2lELGFBQUFBLHlFQUFBQSxDQUFlUDtvQkFBeEIxQzs7Z0JBRVIsSUFBTUQsYUFBeUI7b0JBQzNCQyxNQUFBQTtvQkFDQWtELFNBQVNEO29CQUNURSxXQUFXQyxLQUFLYixHQUFHO29CQUNuQnRDLGlCQUFBQTtvQkFDQVMsV0FBV21DO29CQUNYbEMsV0FBV21DO2dCQUNmO2dCQUVBZCxPQUFPRCxjQUFjaEMsYUFBYUE7Z0JBRWxDLE9BQU95QztZQUNYOzs7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvcG9zdGhvZ1JlcGxheVJlZHV4TG9nZ2VyLnRzPzI1MDMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUmVkdXgtY29tcGF0aWJsZSB0eXBlcyB3aXRob3V0IGRlcGVuZGluZyBvbiBSZWR1eFxuLy8gQ29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3JlZHV4anMvcmVkdXgvYmxvYi82YzhjM2ExMGY2ZTVhMzVmMGM0YTYxNDEzZDdhOTNhNTNlNGYxMWQ0L3NyYy90eXBlcy9hY3Rpb25zLnRzI0wzMlxuXG4vKipcbiAqIEFuIEFjdGlvbiB0eXBlIHdoaWNoIGFjY2VwdHMgYW55IG90aGVyIHByb3BlcnRpZXMuXG4gKiBUaGlzIGlzIG1haW5seSBmb3IgdGhlIHVzZSBvZiB0aGUgYFJlZHVjZXJgIHR5cGUuXG4gKiBUaGlzIGlzIG5vdCBwYXJ0IG9mIGBBY3Rpb25gIGl0c2VsZiB0byBwcmV2ZW50IHR5cGVzIHRoYXQgZXh0ZW5kIGBBY3Rpb25gIGZyb21cbiAqIGhhdmluZyBhbiBpbmRleCBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVW5rbm93bkFjdGlvbiB7XG4gICAgdHlwZTogc3RyaW5nXG4gICAgLy8gQWxsb3dzIGFueSBleHRyYSBwcm9wZXJ0aWVzIHRvIGJlIGRlZmluZWQgaW4gYW4gYWN0aW9uLlxuICAgIFtleHRyYVByb3BzOiBzdHJpbmddOiB1bmtub3duXG59XG5cbi8vIFJlZHV4IG1pZGRsZXdhcmUgdHlwZXNcbmV4cG9ydCB0eXBlIERpc3BhdGNoPEEgPSBVbmtub3duQWN0aW9uPiA9IChhY3Rpb246IEEpID0+IEFcblxuZXhwb3J0IGludGVyZmFjZSBNaWRkbGV3YXJlQVBJPEQgZXh0ZW5kcyBEaXNwYXRjaCA9IERpc3BhdGNoLCBTID0gYW55PiB7XG4gICAgZGlzcGF0Y2g6IERcbiAgICBnZXRTdGF0ZSgpOiBTXG59XG5cbi8vIHdlIG5lZWQgdG8gcGFzcyBhIF9EaXNwYXRjaEV4dCBidXQgVFMgZG9lc24ndCBsaWtlIHRoYXQgaXQgaXMgdW51c2VkXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5leHBvcnQgaW50ZXJmYWNlIE1pZGRsZXdhcmU8X0Rpc3BhdGNoRXh0ID0gb2JqZWN0LCBTID0gYW55LCBEIGV4dGVuZHMgRGlzcGF0Y2ggPSBEaXNwYXRjaD4ge1xuICAgIChhcGk6IE1pZGRsZXdhcmVBUEk8RCwgUz4pOiAobmV4dDogRCkgPT4gKGFjdGlvbjogUGFyYW1ldGVyczxEPlswXSkgPT4gUmV0dXJuVHlwZTxEPlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlZHV4RXZlbnQge1xuICAgIHR5cGU6IHN0cmluZ1xuICAgIHBheWxvYWQ/OiBhbnlcbiAgICB0aW1lc3RhbXA6IG51bWJlclxuICAgIGV4ZWN1dGlvblRpbWVNcz86IG51bWJlclxuICAgIHByZXZTdGF0ZTogYW55XG4gICAgbmV4dFN0YXRlOiBhbnlcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQb3N0SG9nUmVwbGF5UmVkdXhMb2dnZXJDb25maWc8UyA9IGFueT4ge1xuICAgIG1hc2tSZWR1eEFjdGlvbj86IChhY3Rpb246IFVua25vd25BY3Rpb24pID0+IFVua25vd25BY3Rpb24gfCBudWxsXG4gICAgbWFza1JlZHV4U3RhdGU/OiAoc3RhdGU6IFMsIGFjdGlvbj86IFVua25vd25BY3Rpb24pID0+IFNcbiAgICB0aXRsZUZ1bmN0aW9uPzogKHJlZHV4RXZlbnQ6IFJlZHV4RXZlbnQpID0+IHN0cmluZ1xuICAgIGxvZ2dlcj86ICh0aXRsZTogc3RyaW5nLCByZWR1eEV2ZW50OiBSZWR1eEV2ZW50KSA9PiB2b2lkXG4gICAgZGlmZlN0YXRlPzogYm9vbGVhblxufVxuXG4vKipcbiAqIERlZmF1bHQgdGl0bGUgZnVuY3Rpb24gZm9yIFJlZHV4IGV2ZW50c1xuICovXG5mdW5jdGlvbiBkZWZhdWx0VGl0bGVGdW5jdGlvbihyZWR1eEV2ZW50OiBSZWR1eEV2ZW50KTogc3RyaW5nIHtcbiAgICBjb25zdCB7IHR5cGUsIGV4ZWN1dGlvblRpbWVNcyB9ID0gcmVkdXhFdmVudFxuICAgIGNvbnN0IHRpbWVUZXh0ID0gZXhlY3V0aW9uVGltZU1zICE9PSB1bmRlZmluZWQgPyBgICgke2V4ZWN1dGlvblRpbWVNcy50b0ZpeGVkKDIpfW1zKWAgOiAnJ1xuICAgIHJldHVybiBgW1Bvc3RIb2cgUmVkdXggTG9nZ2VyXSAke3R5cGV9JHt0aW1lVGV4dH1gXG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRMb2dnZXIodGl0bGU6IHN0cmluZywgcmVkdXhFdmVudDogUmVkdXhFdmVudCk6IHZvaWQge1xuICAgIGNvbnNvbGUubG9nKHRpdGxlLCByZWR1eEV2ZW50KVxufVxuXG4vKipcbiAqIEdldCBvbmx5IHRoZSBjaGFuZ2VkIGtleXMgZnJvbSB0d28gc3RhdGVzXG4gKiBSZXR1cm5zIHsgcHJldlN0YXRlOiBjaGFuZ2VkS2V5c09ubHksIG5leHRTdGF0ZTogY2hhbmdlZEtleXNPbmx5IH1cbiAqL1xuZnVuY3Rpb24gZ2V0Q2hhbmdlZFN0YXRlS2V5czxTPihwcmV2U3RhdGU6IFMsIG5leHRTdGF0ZTogUyk6IHsgcHJldlN0YXRlOiBQYXJ0aWFsPFM+OyBuZXh0U3RhdGU6IFBhcnRpYWw8Uz4gfSB7XG4gICAgaWYgKHByZXZTdGF0ZSA9PT0gbmV4dFN0YXRlKSB7XG4gICAgICAgIHJldHVybiB7IHByZXZTdGF0ZToge30gYXMgUGFydGlhbDxTPiwgbmV4dFN0YXRlOiB7fSBhcyBQYXJ0aWFsPFM+IH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHByZXZTdGF0ZSAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIG5leHRTdGF0ZSAhPT0gJ29iamVjdCcgfHwgcHJldlN0YXRlID09PSBudWxsIHx8IG5leHRTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4geyBwcmV2U3RhdGU6IHByZXZTdGF0ZSBhcyBQYXJ0aWFsPFM+LCBuZXh0U3RhdGU6IG5leHRTdGF0ZSBhcyBQYXJ0aWFsPFM+IH1cbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcmV2U3RhdGUpIHx8IEFycmF5LmlzQXJyYXkobmV4dFN0YXRlKSkge1xuICAgICAgICByZXR1cm4geyBwcmV2U3RhdGU6IHByZXZTdGF0ZSBhcyBQYXJ0aWFsPFM+LCBuZXh0U3RhdGU6IG5leHRTdGF0ZSBhcyBQYXJ0aWFsPFM+IH1cbiAgICB9XG5cbiAgICBjb25zdCBwcmV2RmlsdGVyZWQ6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fVxuICAgIGNvbnN0IG5leHRGaWx0ZXJlZDogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9XG4gICAgY29uc3QgYWxsS2V5cyA9IG5ldyBTZXQoWy4uLk9iamVjdC5rZXlzKHByZXZTdGF0ZSBhcyBhbnkpLCAuLi5PYmplY3Qua2V5cyhuZXh0U3RhdGUgYXMgYW55KV0pXG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBhbGxLZXlzKSB7XG4gICAgICAgIGNvbnN0IHByZXZWYWx1ZSA9IChwcmV2U3RhdGUgYXMgYW55KVtrZXldXG4gICAgICAgIGNvbnN0IG5leHRWYWx1ZSA9IChuZXh0U3RhdGUgYXMgYW55KVtrZXldXG5cbiAgICAgICAgaWYgKCEoa2V5IGluIChwcmV2U3RhdGUgYXMgYW55KSkpIHtcbiAgICAgICAgICAgIC8vIEtleSB3YXMgYWRkZWRcbiAgICAgICAgICAgIG5leHRGaWx0ZXJlZFtrZXldID0gbmV4dFZhbHVlXG4gICAgICAgIH0gZWxzZSBpZiAoIShrZXkgaW4gKG5leHRTdGF0ZSBhcyBhbnkpKSkge1xuICAgICAgICAgICAgLy8gS2V5IHdhcyByZW1vdmVkXG4gICAgICAgICAgICBwcmV2RmlsdGVyZWRba2V5XSA9IHByZXZWYWx1ZVxuICAgICAgICB9IGVsc2UgaWYgKHByZXZWYWx1ZSAhPT0gbmV4dFZhbHVlKSB7XG4gICAgICAgICAgICAvLyBLZXkgd2FzIGNoYW5nZWRcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB0eXBlb2YgcHJldlZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBuZXh0VmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgcHJldlZhbHVlICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgbmV4dFZhbHVlICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkocHJldlZhbHVlKSAmJlxuICAgICAgICAgICAgICAgICFBcnJheS5pc0FycmF5KG5leHRWYWx1ZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGhhbmRsZSBuZXN0ZWQgb2JqZWN0c1xuICAgICAgICAgICAgICAgIGNvbnN0IG5lc3RlZCA9IGdldENoYW5nZWRTdGF0ZUtleXMocHJldlZhbHVlLCBuZXh0VmFsdWUpXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG5lc3RlZC5wcmV2U3RhdGUpLmxlbmd0aCA+IDAgfHwgT2JqZWN0LmtleXMobmVzdGVkLm5leHRTdGF0ZSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMobmVzdGVkLnByZXZTdGF0ZSkubGVuZ3RoID4gMCkgcHJldkZpbHRlcmVkW2tleV0gPSBuZXN0ZWQucHJldlN0YXRlXG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhuZXN0ZWQubmV4dFN0YXRlKS5sZW5ndGggPiAwKSBuZXh0RmlsdGVyZWRba2V5XSA9IG5lc3RlZC5uZXh0U3RhdGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFByaW1pdGl2ZSB2YWx1ZXMgb3IgYXJyYXlzIC0gaW5jbHVkZSBib3RoXG4gICAgICAgICAgICAgICAgcHJldkZpbHRlcmVkW2tleV0gPSBwcmV2VmFsdWVcbiAgICAgICAgICAgICAgICBuZXh0RmlsdGVyZWRba2V5XSA9IG5leHRWYWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJldlN0YXRlOiBwcmV2RmlsdGVyZWQgYXMgUGFydGlhbDxTPixcbiAgICAgICAgbmV4dFN0YXRlOiBuZXh0RmlsdGVyZWQgYXMgUGFydGlhbDxTPixcbiAgICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFJlZHV4IG1pZGRsZXdhcmUgdGhhdCBsb2dzIGFjdGlvbnMgYW5kIHN0YXRlIGNoYW5nZXMgZm9yIFBvc3RIb2cgc2Vzc2lvbiByZXBsYXlcbiAqIFRoaXMgY2FuIGJlIHVzZWQgYXMgbWlkZGxld2FyZSBpbiBhbnkgUmVkdXggc3RvcmUgdG8gY2FwdHVyZSBzdGF0ZSBjaGFuZ2VzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb3N0aG9nUmVwbGF5UmVkdXhMb2dnZXI8UyA9IGFueT4oXG4gICAgY29uZmlnOiBQb3N0SG9nUmVwbGF5UmVkdXhMb2dnZXJDb25maWc8Uz4gPSB7fVxuKTogTWlkZGxld2FyZTxvYmplY3QsIFM+IHtcbiAgICBjb25zdCB7XG4gICAgICAgIG1hc2tSZWR1eEFjdGlvbiA9IChhY3Rpb246IFVua25vd25BY3Rpb24pID0+IGFjdGlvbixcbiAgICAgICAgbWFza1JlZHV4U3RhdGUgPSAoc3RhdGU6IFMpID0+IHN0YXRlLFxuICAgICAgICB0aXRsZUZ1bmN0aW9uID0gZGVmYXVsdFRpdGxlRnVuY3Rpb24sXG4gICAgICAgIGxvZ2dlciA9IGRlZmF1bHRMb2dnZXIsXG4gICAgICAgIGRpZmZTdGF0ZSA9IHRydWUsXG4gICAgfSA9IGNvbmZpZ1xuXG4gICAgcmV0dXJuIChzdG9yZTogTWlkZGxld2FyZUFQSTxEaXNwYXRjaCwgUz4pID0+IChuZXh0OiBEaXNwYXRjaCkgPT4gKGFjdGlvbjogVW5rbm93bkFjdGlvbikgPT4ge1xuICAgICAgICAvLyBHZXQgdGhlIHN0YXRlIGJlZm9yZSB0aGUgYWN0aW9uXG4gICAgICAgIGNvbnN0IHByZXZTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKClcblxuICAgICAgICAvLyBUcmFjayBleGVjdXRpb24gdGltZVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGF0L2NvbXBhdFxuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5leHQoYWN0aW9uKVxuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wYXQvY29tcGF0XG4gICAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgICBjb25zdCBleGVjdXRpb25UaW1lTXMgPSBlbmRUaW1lIC0gc3RhcnRUaW1lXG5cbiAgICAgICAgLy8gR2V0IHRoZSBzdGF0ZSBhZnRlciB0aGUgYWN0aW9uXG4gICAgICAgIGNvbnN0IG5leHRTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKClcblxuICAgICAgICBjb25zdCBtYXNrZWRBY3Rpb24gPSBtYXNrUmVkdXhBY3Rpb24oYWN0aW9uKVxuXG4gICAgICAgIGlmICghbWFza2VkQWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcHBseSBtYXNraW5nIHRvIHN0YXRlc1xuICAgICAgICBjb25zdCBtYXNrZWRQcmV2U3RhdGUgPSBtYXNrUmVkdXhTdGF0ZShwcmV2U3RhdGUsIG1hc2tlZEFjdGlvbilcbiAgICAgICAgY29uc3QgbWFza2VkTmV4dFN0YXRlID0gbWFza1JlZHV4U3RhdGUobmV4dFN0YXRlLCBtYXNrZWRBY3Rpb24pXG5cbiAgICAgICAgbGV0IGZpbHRlcmVkUHJldlN0YXRlOiBQYXJ0aWFsPFM+XG4gICAgICAgIGxldCBmaWx0ZXJlZE5leHRTdGF0ZTogUGFydGlhbDxTPlxuICAgICAgICBpZiAoZGlmZlN0YXRlKSB7XG4gICAgICAgICAgICBjb25zdCB7IHByZXZTdGF0ZTogZGlmZmVkUHJldlN0YXRlLCBuZXh0U3RhdGU6IGRpZmZlZE5leHRTdGF0ZSB9ID0gZ2V0Q2hhbmdlZFN0YXRlS2V5cyhcbiAgICAgICAgICAgICAgICBtYXNrZWRQcmV2U3RhdGUsXG4gICAgICAgICAgICAgICAgbWFza2VkTmV4dFN0YXRlXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBmaWx0ZXJlZFByZXZTdGF0ZSA9IGRpZmZlZFByZXZTdGF0ZVxuICAgICAgICAgICAgZmlsdGVyZWROZXh0U3RhdGUgPSBkaWZmZWROZXh0U3RhdGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpbHRlcmVkUHJldlN0YXRlID0gbWFza2VkUHJldlN0YXRlXG4gICAgICAgICAgICBmaWx0ZXJlZE5leHRTdGF0ZSA9IG1hc2tlZE5leHRTdGF0ZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyB0eXBlLCAuLi5hY3Rpb25EYXRhIH0gPSBtYXNrZWRBY3Rpb25cblxuICAgICAgICBjb25zdCByZWR1eEV2ZW50OiBSZWR1eEV2ZW50ID0ge1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHBheWxvYWQ6IGFjdGlvbkRhdGEsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgICBleGVjdXRpb25UaW1lTXMsXG4gICAgICAgICAgICBwcmV2U3RhdGU6IGZpbHRlcmVkUHJldlN0YXRlLFxuICAgICAgICAgICAgbmV4dFN0YXRlOiBmaWx0ZXJlZE5leHRTdGF0ZSxcbiAgICAgICAgfVxuXG4gICAgICAgIGxvZ2dlcih0aXRsZUZ1bmN0aW9uKHJlZHV4RXZlbnQpLCByZWR1eEV2ZW50KVxuXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG59XG4iXSwibmFtZXMiOlsiZGVmYXVsdFRpdGxlRnVuY3Rpb24iLCJyZWR1eEV2ZW50IiwidHlwZSIsImV4ZWN1dGlvblRpbWVNcyIsInRpbWVUZXh0IiwidW5kZWZpbmVkIiwidG9GaXhlZCIsImRlZmF1bHRMb2dnZXIiLCJ0aXRsZSIsImNvbnNvbGUiLCJsb2ciLCJnZXRDaGFuZ2VkU3RhdGVLZXlzIiwicHJldlN0YXRlIiwibmV4dFN0YXRlIiwiQXJyYXkiLCJpc0FycmF5IiwicHJldkZpbHRlcmVkIiwibmV4dEZpbHRlcmVkIiwiYWxsS2V5cyIsIlNldCIsIk9iamVjdCIsImtleXMiLCJrZXkiLCJwcmV2VmFsdWUiLCJuZXh0VmFsdWUiLCJuZXN0ZWQiLCJsZW5ndGgiLCJwb3N0aG9nUmVwbGF5UmVkdXhMb2dnZXIiLCJjb25maWciLCJtYXNrUmVkdXhBY3Rpb24iLCJhY3Rpb24iLCJtYXNrUmVkdXhTdGF0ZSIsInN0YXRlIiwidGl0bGVGdW5jdGlvbiIsImxvZ2dlciIsImRpZmZTdGF0ZSIsInN0b3JlIiwibmV4dCIsImdldFN0YXRlIiwic3RhcnRUaW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJyZXN1bHQiLCJlbmRUaW1lIiwibWFza2VkQWN0aW9uIiwibWFza2VkUHJldlN0YXRlIiwibWFza2VkTmV4dFN0YXRlIiwiZmlsdGVyZWRQcmV2U3RhdGUiLCJmaWx0ZXJlZE5leHRTdGF0ZSIsImRpZmZlZFByZXZTdGF0ZSIsImRpZmZlZE5leHRTdGF0ZSIsImFjdGlvbkRhdGEiLCJwYXlsb2FkIiwidGltZXN0YW1wIiwiRGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/posthogReplayReduxLogger.ts\n'
                )
            )

            /***/
        },
})
